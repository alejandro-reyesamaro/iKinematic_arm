/*
* MATLAB Compiler: 4.14 (R2010b)
* Date: Wed Jan 05 03:21:59 2011
* Arguments: "-B" "macro_default" "-W" "dotnet:IK_ParticleFilter,MATLAB_PFIK,0.0,private"
* "-T" "link:lib" "-d" "C:\Documents and
* Settings\Administrador\Escritorio\ProMATLAB2010\IK_ParticleFilter\src" "-w"
* "enable:specified_file_mismatch" "-w" "enable:repeated_file" "-w"
* "enable:switch_ignored" "-w" "enable:missing_lib_sentinel" "-w" "enable:demo_license"
* "-v" "class{MATLAB_PFIK:C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\angulo.m,C:\Do
* cuments and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2CCDquate
* rnions.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2image.m,
* C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2position
* s.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainCCDQuTemS
* amplig.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainEndEffect
* orPosition.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainQuaternio
* nUniformSampling.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainQuTEMSamp
* ling.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\createChain.m,
* C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\createParticle
* .m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\dentro.m,C:\Do
* cuments and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\euclidianDista
* nce.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\evalua_recta.m
* ,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\imageDistance.
* m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\mas.m,C:\Docum
* ents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\obstaculo_crec
* ido.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\PF.m,C:\Docume
* nts and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\pik.m,C:\Docum
* ents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\point2quaterni
* on.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\pointDistance.
* m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\positions2chai
* n.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\PrtFltr_MkwskS
* um.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion.m,C
* :\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion2poi
* nt.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionConj
* ugate.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionDist
* ance.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionExpo
* nentialMap.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionInne
* rProduct.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionLoga
* rithmicMap.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionNorm
* .m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionNorm
* alize.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionProd
* uct.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionQuTE
* MSampling.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionRota
* tion.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternionUnif
* ormSampling.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\remostrejar.m,
* C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\rotation2quate
* rnion.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\S_Touch.m,C:\D
* ocuments and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\setGaussianPar
* ameters.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\slerp.m,C:\Doc
* uments and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\testQuTEM.m,C:
* \Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\vectors2quater
* nion.m,C:\Documents and Settings\Administrador\Escritorio\My
* Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\weightFunction
* .m}" 
*/
using System;
using System.Reflection;
using System.IO;
using MathWorks.MATLAB.NET.Arrays;
using MathWorks.MATLAB.NET.Utility;

#if SHARED
[assembly: System.Reflection.AssemblyKeyFile(@"")]
#endif

namespace IK_ParticleFilter
{
  /// <summary>
  /// The MATLAB_PFIK class provides a CLS compliant, MWArray interface to the
  /// M-functions contained in the files:
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\angulo.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2CCDq
  /// uaternions.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2imag
  /// e.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chain2posi
  /// tions.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainCCDQu
  /// TemSamplig.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainEndEf
  /// fectorPosition.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainQuate
  /// rnionUniformSampling.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\chainQuTEM
  /// Sampling.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\createChai
  /// n.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\createPart
  /// icle.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\dentro.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\euclidianD
  /// istance.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\evalua_rec
  /// ta.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\imageDista
  /// nce.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\mas.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\obstaculo_
  /// crecido.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\PF.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\pik.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\point2quat
  /// ernion.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\pointDista
  /// nce.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\positions2
  /// chain.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\PrtFltr_Mk
  /// wskSum.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// .m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// 2point.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Conjugate.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Distance.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// ExponentialMap.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// InnerProduct.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// LogarithmicMap.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Norm.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Normalize.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Product.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// QuTEMSampling.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// Rotation.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\quaternion
  /// UniformSampling.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\remostreja
  /// r.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\rotation2q
  /// uaternion.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\S_Touch.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\setGaussia
  /// nParameters.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\slerp.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\testQuTEM.
  /// m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\vectors2qu
  /// aternion.m
  /// <newpara></newpara>
  /// C:\Documents and Settings\Administrador\Escritorio\My
  /// Work\MATH\ParticleFiltering\IK_ParticleFiltering\IK_ParticleFiltering_NET\weightFunc
  /// tion.m
  /// <newpara></newpara>
  /// deployprint.m
  /// <newpara></newpara>
  /// printdlg.m
  /// </summary>
  /// <remarks>
  /// @Version 0.0
  /// </remarks>
  public class MATLAB_PFIK : IDisposable
  {
    #region Constructors

    /// <summary internal= "true">
    /// The static constructor instantiates and initializes the MATLAB Compiler Runtime
    /// instance.
    /// </summary>
    static MATLAB_PFIK()
    {
      if (MWMCR.MCRAppInitialized)
      {
        Assembly assembly= Assembly.GetExecutingAssembly();

        string ctfFilePath= assembly.Location;

        int lastDelimiter= ctfFilePath.LastIndexOf(@"\");

        ctfFilePath= ctfFilePath.Remove(lastDelimiter, (ctfFilePath.Length - lastDelimiter));

        string ctfFileName = "IK_ParticleFilter.ctf";

        Stream embeddedCtfStream = null;

        String[] resourceStrings = assembly.GetManifestResourceNames();

        foreach (String name in resourceStrings)
        {
          if (name.Contains(ctfFileName))
          {
            embeddedCtfStream = assembly.GetManifestResourceStream(name);
            break;
          }
        }
        mcr= new MWMCR("",
                       ctfFilePath, embeddedCtfStream, true);
      }
      else
      {
        throw new ApplicationException("MWArray assembly could not be initialized");
      }
    }


    /// <summary>
    /// Constructs a new instance of the MATLAB_PFIK class.
    /// </summary>
    public MATLAB_PFIK()
    {
        if (MWMCR.MCRAppInitialized)
        {
            Assembly assembly = Assembly.GetExecutingAssembly();

            string ctfFilePath = assembly.Location;

            int lastDelimiter = ctfFilePath.LastIndexOf(@"\");

            ctfFilePath = ctfFilePath.Remove(lastDelimiter, (ctfFilePath.Length - lastDelimiter));

            string ctfFileName = "IK_ParticleFilter.ctf";

            Stream embeddedCtfStream = null;

            String[] resourceStrings = assembly.GetManifestResourceNames();

            foreach (String name in resourceStrings)
            {
                if (name.Contains(ctfFileName))
                {
                    embeddedCtfStream = assembly.GetManifestResourceStream(name);
                    break;
                }
            }
            mcr = new MWMCR("",
                           ctfFilePath, embeddedCtfStream, true);
        }
        else
        {
            throw new ApplicationException("MWArray assembly could not be initialized");
        }
    }


    #endregion Constructors

    #region Finalize

    /// <summary internal= "true">
    /// Class destructor called by the CLR garbage collector.
    /// </summary>
    ~MATLAB_PFIK()
    {
      Dispose(false);
    }


    /// <summary>
    /// Frees the native resources associated with this object
    /// </summary>
    public void Dispose()
    {
      Dispose(true);

      GC.SuppressFinalize(this);
    }


    /// <summary internal= "true">
    /// Internal dispose function
    /// </summary>
    protected virtual void Dispose(bool disposing)
    {
      if (!disposed)
      {
        disposed= true;

        if (disposing)
        {
          // Free managed resources;
        }

        // Free native resources
      }
    }


    #endregion Finalize

    #region Methods

    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray angulo()
    {
      return mcr.EvaluateFunction("angulo", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray angulo(MWArray p1)
    {
      return mcr.EvaluateFunction("angulo", p1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray angulo(MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction("angulo", p1, p2);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <param name="antan">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray angulo(MWArray p1, MWArray p2, MWArray antan)
    {
      return mcr.EvaluateFunction("angulo", p1, p2, antan);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] angulo(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "angulo", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] angulo(int numArgsOut, MWArray p1)
    {
      return mcr.EvaluateFunction(numArgsOut, "angulo", p1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] angulo(int numArgsOut, MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction(numArgsOut, "angulo", p1, p2);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the angulo M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <param name="antan">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] angulo(int numArgsOut, MWArray p1, MWArray p2, MWArray antan)
    {
      return mcr.EvaluateFunction(numArgsOut, "angulo", p1, p2, antan);
    }


    /// <summary>
    /// Provides an interface for the angulo function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void angulo(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("angulo", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2CCDquaternions()
    {
      return mcr.EvaluateFunction("chain2CCDquaternions", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2CCDquaternions(MWArray chain)
    {
      return mcr.EvaluateFunction("chain2CCDquaternions", chain);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2CCDquaternions(MWArray chain, MWArray goal)
    {
      return mcr.EvaluateFunction("chain2CCDquaternions", chain, goal);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2CCDquaternions(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2CCDquaternions", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2CCDquaternions(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2CCDquaternions", chain);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the chain2CCDquaternions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2CCDquaternions(int numArgsOut, MWArray chain, MWArray goal)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2CCDquaternions", chain, goal);
    }


    /// <summary>
    /// Provides an interface for the chain2CCDquaternions function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// chain copy
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chain2CCDquaternions(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                           argsIn)
    {
      mcr.EvaluateFunction("chain2CCDquaternions", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2image()
    {
      return mcr.EvaluateFunction("chain2image", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2image(MWArray chain)
    {
      return mcr.EvaluateFunction("chain2image", chain);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="penSize">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2image(MWArray chain, MWArray penSize)
    {
      return mcr.EvaluateFunction("chain2image", chain, penSize);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="penSize">Input argument #2</param>
    /// <param name="image_in1">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2image(MWArray chain, MWArray penSize, MWArray image_in1)
    {
      return mcr.EvaluateFunction("chain2image", chain, penSize, image_in1);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2image(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2image", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2image(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2image", chain);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="penSize">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2image(int numArgsOut, MWArray chain, MWArray penSize)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2image", chain, penSize);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the chain2image M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="penSize">Input argument #2</param>
    /// <param name="image_in1">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2image(int numArgsOut, MWArray chain, MWArray penSize, MWArray 
                           image_in1)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2image", chain, penSize, image_in1);
    }


    /// <summary>
    /// Provides an interface for the chain2image function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// joints positions of the chain
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chain2image(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("chain2image", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the chain2positions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Valid for matrix</remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2positions()
    {
      return mcr.EvaluateFunction("chain2positions", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the chain2positions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Valid for matrix</remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chain2positions(MWArray chain)
    {
      return mcr.EvaluateFunction("chain2positions", chain);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chain2positions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Valid for matrix</remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2positions(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2positions", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chain2positions
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Valid for matrix</remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chain2positions(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chain2positions", chain);
    }


    /// <summary>
    /// Provides an interface for the chain2positions function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// TODO: Valid for matrix</remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chain2positions(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("chain2positions", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig()
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig(MWArray goal)
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", goal);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig(MWArray goal, MWArray g)
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", goal, g);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig(MWArray goal, MWArray g, MWArray chain)
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", goal, g, chain);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="f">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig(MWArray goal, MWArray g, MWArray chain, MWArray f)
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", goal, g, chain, f);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="f">Input argument #4</param>
    /// <param name="epsilon">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainCCDQuTemSamplig(MWArray goal, MWArray g, MWArray chain, MWArray 
                                  f, MWArray epsilon)
    {
      return mcr.EvaluateFunction("chainCCDQuTemSamplig", goal, g, chain, f, epsilon);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut, MWArray goal)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", goal);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut, MWArray goal, MWArray g)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", goal, g);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut, MWArray goal, MWArray g, 
                                    MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", goal, g, chain);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="f">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut, MWArray goal, MWArray g, 
                                    MWArray chain, MWArray f)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", goal, g, chain, f);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the chainCCDQuTemSamplig
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="g">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="f">Input argument #4</param>
    /// <param name="epsilon">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainCCDQuTemSamplig(int numArgsOut, MWArray goal, MWArray g, 
                                    MWArray chain, MWArray f, MWArray epsilon)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainCCDQuTemSamplig", goal, g, chain, f, epsilon);
    }


    /// <summary>
    /// Provides an interface for the chainCCDQuTemSamplig function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// compute joints quaternion rotation for CCD. From quaternion of joint to vector
    /// joint
    /// position-->goal
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chainCCDQuTemSamplig(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                           argsIn)
    {
      mcr.EvaluateFunction("chainCCDQuTemSamplig", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// chainEndEffectorPosition M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainEndEffectorPosition()
    {
      return mcr.EvaluateFunction("chainEndEffectorPosition", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// chainEndEffectorPosition M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainEndEffectorPosition(MWArray chain)
    {
      return mcr.EvaluateFunction("chainEndEffectorPosition", chain);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chainEndEffectorPosition
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainEndEffectorPosition(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainEndEffectorPosition", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chainEndEffectorPosition
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainEndEffectorPosition(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainEndEffectorPosition", chain);
    }


    /// <summary>
    /// Provides an interface for the chainEndEffectorPosition function in which the
    /// input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chainEndEffectorPosition(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                               argsIn)
    {
      mcr.EvaluateFunction("chainEndEffectorPosition", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuaternionUniformSampling()
    {
      return mcr.EvaluateFunction("chainQuaternionUniformSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samples">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuaternionUniformSampling(MWArray samples)
    {
      return mcr.EvaluateFunction("chainQuaternionUniformSampling", samples);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samples">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuaternionUniformSampling(MWArray samples, MWArray chain)
    {
      return mcr.EvaluateFunction("chainQuaternionUniformSampling", samples, chain);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuaternionUniformSampling(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuaternionUniformSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samples">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuaternionUniformSampling(int numArgsOut, MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuaternionUniformSampling", samples);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the
    /// chainQuaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samples">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuaternionUniformSampling(int numArgsOut, MWArray samples, 
                                              MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuaternionUniformSampling", samples, chain);
    }


    /// <summary>
    /// Provides an interface for the chainQuaternionUniformSampling function in which
    /// the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chainQuaternionUniformSampling(int numArgsOut, ref MWArray[] argsOut, 
                                     MWArray[] argsIn)
    {
      mcr.EvaluateFunction("chainQuaternionUniformSampling", numArgsOut, ref argsOut, 
                                     argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuTEMSampling()
    {
      return mcr.EvaluateFunction("chainQuTEMSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="g">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuTEMSampling(MWArray g)
    {
      return mcr.EvaluateFunction("chainQuTEMSampling", g);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="g">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray chainQuTEMSampling(MWArray g, MWArray chain)
    {
      return mcr.EvaluateFunction("chainQuTEMSampling", g, chain);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuTEMSampling(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuTEMSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="g">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuTEMSampling(int numArgsOut, MWArray g)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuTEMSampling", g);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the chainQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="g">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] chainQuTEMSampling(int numArgsOut, MWArray g, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "chainQuTEMSampling", g, chain);
    }


    /// <summary>
    /// Provides an interface for the chainQuTEMSampling function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void chainQuTEMSampling(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("chainQuTEMSampling", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the createChain M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createChain()
    {
      return mcr.EvaluateFunction("createChain", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the createChain M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="vectores_canonicos">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createChain(MWArray vectores_canonicos)
    {
      return mcr.EvaluateFunction("createChain", vectores_canonicos);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the createChain M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createChain(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "createChain", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the createChain M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vectores_canonicos">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createChain(int numArgsOut, MWArray vectores_canonicos)
    {
      return mcr.EvaluateFunction(numArgsOut, "createChain", vectores_canonicos);
    }


    /// <summary>
    /// Provides an interface for the createChain function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void createChain(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("createChain", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the createParticle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createParticle()
    {
      return mcr.EvaluateFunction("createParticle", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the createParticle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createParticle(MWArray chain)
    {
      return mcr.EvaluateFunction("createParticle", chain);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the createParticle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createParticle(MWArray chain, MWArray samples)
    {
      return mcr.EvaluateFunction("createParticle", chain, samples);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the createParticle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <param name="pg">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createParticle(MWArray chain, MWArray samples, MWArray pg)
    {
      return mcr.EvaluateFunction("createParticle", chain, samples, pg);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the createParticle
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <param name="pg">Input argument #3</param>
    /// <param name="equal">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray createParticle(MWArray chain, MWArray samples, MWArray pg, MWArray 
                            equal)
    {
      return mcr.EvaluateFunction("createParticle", chain, samples, pg, equal);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the createParticle M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createParticle(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "createParticle", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the createParticle M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createParticle(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "createParticle", chain);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the createParticle M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createParticle(int numArgsOut, MWArray chain, MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "createParticle", chain, samples);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the createParticle M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <param name="pg">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createParticle(int numArgsOut, MWArray chain, MWArray samples, 
                              MWArray pg)
    {
      return mcr.EvaluateFunction(numArgsOut, "createParticle", chain, samples, pg);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the createParticle M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="samples">Input argument #2</param>
    /// <param name="pg">Input argument #3</param>
    /// <param name="equal">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] createParticle(int numArgsOut, MWArray chain, MWArray samples, 
                              MWArray pg, MWArray equal)
    {
      return mcr.EvaluateFunction(numArgsOut, "createParticle", chain, samples, pg, equal);
    }


    /// <summary>
    /// Provides an interface for the createParticle function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void createParticle(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("createParticle", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray dentro()
    {
      return mcr.EvaluateFunction("dentro", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="P">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray dentro(MWArray P)
    {
      return mcr.EvaluateFunction("dentro", P);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="P">Input argument #1</param>
    /// <param name="p">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray dentro(MWArray P, MWArray p)
    {
      return mcr.EvaluateFunction("dentro", P, p);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] dentro(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "dentro", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="P">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] dentro(int numArgsOut, MWArray P)
    {
      return mcr.EvaluateFunction(numArgsOut, "dentro", P);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the dentro M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="P">Input argument #1</param>
    /// <param name="p">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] dentro(int numArgsOut, MWArray P, MWArray p)
    {
      return mcr.EvaluateFunction(numArgsOut, "dentro", P, p);
    }


    /// <summary>
    /// Provides an interface for the dentro function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Esta funcion nos dir'a si un punto est'a dentro de un poligono (convexo)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void dentro(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("dentro", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray euclidianDistance()
    {
      return mcr.EvaluateFunction("euclidianDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray euclidianDistance(MWArray p1)
    {
      return mcr.EvaluateFunction("euclidianDistance", p1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray euclidianDistance(MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction("euclidianDistance", p1, p2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] euclidianDistance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "euclidianDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] euclidianDistance(int numArgsOut, MWArray p1)
    {
      return mcr.EvaluateFunction(numArgsOut, "euclidianDistance", p1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the euclidianDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] euclidianDistance(int numArgsOut, MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction(numArgsOut, "euclidianDistance", p1, p2);
    }


    /// <summary>
    /// Provides an interface for the euclidianDistance function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void euclidianDistance(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("euclidianDistance", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the evalua_recta
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evalua_recta()
    {
      return mcr.EvaluateFunction("evalua_recta", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the evalua_recta
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="r">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evalua_recta(MWArray r)
    {
      return mcr.EvaluateFunction("evalua_recta", r);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the evalua_recta
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="r">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray evalua_recta(MWArray r, MWArray x)
    {
      return mcr.EvaluateFunction("evalua_recta", r, x);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the evalua_recta M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evalua_recta(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "evalua_recta", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the evalua_recta M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="r">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evalua_recta(int numArgsOut, MWArray r)
    {
      return mcr.EvaluateFunction(numArgsOut, "evalua_recta", r);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the evalua_recta M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="r">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] evalua_recta(int numArgsOut, MWArray r, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "evalua_recta", r, x);
    }


    /// <summary>
    /// Provides an interface for the evalua_recta function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Calculo de la ecuacin d ela recta
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void evalua_recta(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("evalua_recta", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the imageDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray imageDistance()
    {
      return mcr.EvaluateFunction("imageDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the imageDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="image">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray imageDistance(MWArray image)
    {
      return mcr.EvaluateFunction("imageDistance", image);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the imageDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="image">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray imageDistance(MWArray image, MWArray chain)
    {
      return mcr.EvaluateFunction("imageDistance", image, chain);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the imageDistance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] imageDistance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "imageDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the imageDistance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="image">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] imageDistance(int numArgsOut, MWArray image)
    {
      return mcr.EvaluateFunction(numArgsOut, "imageDistance", image);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the imageDistance M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="image">Input argument #1</param>
    /// <param name="chain">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] imageDistance(int numArgsOut, MWArray image, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "imageDistance", image, chain);
    }


    /// <summary>
    /// Provides an interface for the imageDistance function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// binary image
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void imageDistance(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("imageDistance", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray mas()
    {
      return mcr.EvaluateFunction("mas", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray mas(MWArray p1)
    {
      return mcr.EvaluateFunction("mas", p1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray mas(MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction("mas", p1, p2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] mas(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "mas", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] mas(int numArgsOut, MWArray p1)
    {
      return mcr.EvaluateFunction(numArgsOut, "mas", p1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the mas M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] mas(int numArgsOut, MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction(numArgsOut, "mas", p1, p2);
    }


    /// <summary>
    /// Provides an interface for the mas function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Retorna la suma vectorial de dos puntos
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void mas(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("mas", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray obstaculo_crecido()
    {
      return mcr.EvaluateFunction("obstaculo_crecido", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="a">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray obstaculo_crecido(MWArray a)
    {
      return mcr.EvaluateFunction("obstaculo_crecido", a);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="a">Input argument #1</param>
    /// <param name="L_puntos">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray obstaculo_crecido(MWArray a, MWArray L_puntos)
    {
      return mcr.EvaluateFunction("obstaculo_crecido", a, L_puntos);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] obstaculo_crecido(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "obstaculo_crecido", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="a">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] obstaculo_crecido(int numArgsOut, MWArray a)
    {
      return mcr.EvaluateFunction(numArgsOut, "obstaculo_crecido", a);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the obstaculo_crecido
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="a">Input argument #1</param>
    /// <param name="L_puntos">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] obstaculo_crecido(int numArgsOut, MWArray a, MWArray L_puntos)
    {
      return mcr.EvaluateFunction(numArgsOut, "obstaculo_crecido", a, L_puntos);
    }


    /// <summary>
    /// Provides an interface for the obstaculo_crecido function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Esta funcin calcula espacio prohibido de configuraciones de un brazo
    /// mecanico representado por el segmento "a". El resultado es una lista de
    /// puntos que representan el obstculo crecido: "RmasP"
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void obstaculo_crecido(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("obstaculo_crecido", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PF()
    {
      return mcr.EvaluateFunction("PF", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PF(MWArray goal)
    {
      return mcr.EvaluateFunction("PF", goal);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="particles">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PF(MWArray goal, MWArray particles)
    {
      return mcr.EvaluateFunction("PF", goal, particles);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="goal">Input argument #1</param>
    /// <param name="particles">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PF(MWArray goal, MWArray particles, MWArray S)
    {
      return mcr.EvaluateFunction("PF", goal, particles, S);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PF(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "PF", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PF(int numArgsOut, MWArray goal)
    {
      return mcr.EvaluateFunction(numArgsOut, "PF", goal);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="particles">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PF(int numArgsOut, MWArray goal, MWArray particles)
    {
      return mcr.EvaluateFunction(numArgsOut, "PF", goal, particles);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the PF M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="goal">Input argument #1</param>
    /// <param name="particles">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PF(int numArgsOut, MWArray goal, MWArray particles, MWArray S)
    {
      return mcr.EvaluateFunction(numArgsOut, "PF", goal, particles, S);
    }


    /// <summary>
    /// Provides an interface for the PF function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void PF(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("PF", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik()
    {
      return mcr.EvaluateFunction("pik", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter)
    {
      return mcr.EvaluateFunction("pik", max_iter);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter, MWArray epsilon)
    {
      return mcr.EvaluateFunction("pik", max_iter, epsilon);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter, MWArray epsilon, MWArray chain)
    {
      return mcr.EvaluateFunction("pik", max_iter, epsilon, chain);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter, MWArray epsilon, MWArray chain, MWArray goal)
    {
      return mcr.EvaluateFunction("pik", max_iter, epsilon, chain, goal);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <param name="particles">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter, MWArray epsilon, MWArray chain, MWArray goal, 
                 MWArray particles)
    {
      return mcr.EvaluateFunction("pik", max_iter, epsilon, chain, goal, particles);
    }


    /// <summary>
    /// Provides a single output, 6-input MWArrayinterface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <param name="particles">Input argument #5</param>
    /// <param name="S">Input argument #6</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pik(MWArray max_iter, MWArray epsilon, MWArray chain, MWArray goal, 
                 MWArray particles, MWArray S)
    {
      return mcr.EvaluateFunction("pik", max_iter, epsilon, chain, goal, particles, S);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter, MWArray epsilon)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter, epsilon);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter, MWArray epsilon, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter, epsilon, chain);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter, MWArray epsilon, MWArray 
                   chain, MWArray goal)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter, epsilon, chain, goal);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <param name="particles">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter, MWArray epsilon, MWArray 
                   chain, MWArray goal, MWArray particles)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter, epsilon, chain, goal, particles);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the pik M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="chain">Input argument #3</param>
    /// <param name="goal">Input argument #4</param>
    /// <param name="particles">Input argument #5</param>
    /// <param name="S">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pik(int numArgsOut, MWArray max_iter, MWArray epsilon, MWArray 
                   chain, MWArray goal, MWArray particles, MWArray S)
    {
      return mcr.EvaluateFunction(numArgsOut, "pik", max_iter, epsilon, chain, goal, particles, S);
    }


    /// <summary>
    /// Provides an interface for the pik function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// chainResult = chain;
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void pik(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("pik", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the point2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray point2quaternion()
    {
      return mcr.EvaluateFunction("point2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the point2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray point2quaternion(MWArray p)
    {
      return mcr.EvaluateFunction("point2quaternion", p);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the point2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] point2quaternion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "point2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the point2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] point2quaternion(int numArgsOut, MWArray p)
    {
      return mcr.EvaluateFunction(numArgsOut, "point2quaternion", p);
    }


    /// <summary>
    /// Provides an interface for the point2quaternion function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void point2quaternion(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("point2quaternion", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the pointDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pointDistance()
    {
      return mcr.EvaluateFunction("pointDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the pointDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pointDistance(MWArray p1)
    {
      return mcr.EvaluateFunction("pointDistance", p1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the pointDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray pointDistance(MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction("pointDistance", p1, p2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the pointDistance M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pointDistance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "pointDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the pointDistance M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pointDistance(int numArgsOut, MWArray p1)
    {
      return mcr.EvaluateFunction(numArgsOut, "pointDistance", p1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the pointDistance M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p1">Input argument #1</param>
    /// <param name="p2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] pointDistance(int numArgsOut, MWArray p1, MWArray p2)
    {
      return mcr.EvaluateFunction(numArgsOut, "pointDistance", p1, p2);
    }


    /// <summary>
    /// Provides an interface for the pointDistance function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void pointDistance(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("pointDistance", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray positions2chain()
    {
      return mcr.EvaluateFunction("positions2chain", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray positions2chain(MWArray x)
    {
      return mcr.EvaluateFunction("positions2chain", x);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray positions2chain(MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("positions2chain", x, y);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] positions2chain(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "positions2chain", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] positions2chain(int numArgsOut, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "positions2chain", x);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the positions2chain
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="x">Input argument #1</param>
    /// <param name="y">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] positions2chain(int numArgsOut, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "positions2chain", x, y);
    }


    /// <summary>
    /// Provides an interface for the positions2chain function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Se asume que la primera posicion es el (0,0)
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void positions2chain(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("positions2chain", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum()
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S, MWArray 
                              x_axis)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis);
    }


    /// <summary>
    /// Provides a single output, 5-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S, MWArray 
                              x_axis, MWArray y_axis)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis);
    }


    /// <summary>
    /// Provides a single output, 6-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S, MWArray 
                              x_axis, MWArray y_axis, MWArray obj)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj);
    }


    /// <summary>
    /// Provides a single output, 7-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <param name="samples">Input argument #7</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S, MWArray 
                              x_axis, MWArray y_axis, MWArray obj, MWArray samples)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj, samples);
    }


    /// <summary>
    /// Provides a single output, 8-input MWArrayinterface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <param name="samples">Input argument #7</param>
    /// <param name="media_gausiana">Input argument #8</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray PrtFltr_MkwskSum(MWArray max_iter, MWArray epsilon, MWArray S, MWArray 
                              x_axis, MWArray y_axis, MWArray obj, MWArray samples, 
                              MWArray media_gausiana)
    {
      return mcr.EvaluateFunction("PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj, samples, media_gausiana);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S, MWArray x_axis)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S, MWArray x_axis, MWArray y_axis)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S, MWArray x_axis, MWArray y_axis, MWArray obj)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj);
    }


    /// <summary>
    /// Provides the standard 7-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <param name="samples">Input argument #7</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S, MWArray x_axis, MWArray y_axis, MWArray obj, 
                                MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj, samples);
    }


    /// <summary>
    /// Provides the standard 8-input MWArray interface to the PrtFltr_MkwskSum
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="max_iter">Input argument #1</param>
    /// <param name="epsilon">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <param name="x_axis">Input argument #4</param>
    /// <param name="y_axis">Input argument #5</param>
    /// <param name="obj">Input argument #6</param>
    /// <param name="samples">Input argument #7</param>
    /// <param name="media_gausiana">Input argument #8</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] PrtFltr_MkwskSum(int numArgsOut, MWArray max_iter, MWArray epsilon, 
                                MWArray S, MWArray x_axis, MWArray y_axis, MWArray obj, 
                                MWArray samples, MWArray media_gausiana)
    {
      return mcr.EvaluateFunction(numArgsOut, "PrtFltr_MkwskSum", max_iter, epsilon, S, x_axis, y_axis, obj, samples, media_gausiana);
    }


    /// <summary>
    /// Provides an interface for the PrtFltr_MkwskSum function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Esta funcion es la que engloba los algoritmos de Filtro de Particulas
    /// y Suma de Minkowski. Como parmetros se le pasa:
    /// max_iter: Maximo de iteraciones que realizara el filtraje
    /// epsilon:  tolerancia de cercana con el objetivo
    /// S:        el sistema de obstaculos
    /// x_axis:   posiciones en el eje x de la cadena en su posicin "inicial" 
    /// y_axis:   posiciones en el eje y de la cadena en su posicin "inicial" 
    /// obj:      objetivo intermedio 
    /// samples:  cantidad de particulas que se generaran
    /// media_gausiana: media para la generacin de particulas (0.03)
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos, ordenados tomando como principio el que menos
    /// coordenada "y" tenga (menos "x") en caso de empate y siguiendo el orden
    /// inverso a a las manesillas del reloj
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void PrtFltr_MkwskSum(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("PrtFltr_MkwskSum", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternion()
    {
      return mcr.EvaluateFunction("quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="s">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternion(MWArray s)
    {
      return mcr.EvaluateFunction("quaternion", s);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="s">Input argument #1</param>
    /// <param name="p">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternion(MWArray s, MWArray p)
    {
      return mcr.EvaluateFunction("quaternion", s, p);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="s">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternion(int numArgsOut, MWArray s)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternion", s);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternion M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="s">Input argument #1</param>
    /// <param name="p">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternion(int numArgsOut, MWArray s, MWArray p)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternion", s, p);
    }


    /// <summary>
    /// Provides an interface for the quaternion function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// TODO: Tal vegada s'hauria de fer un get i set per quaternion. Per ara ho
    /// deixam aix.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternion(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("quaternion", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternion2point
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternion2point()
    {
      return mcr.EvaluateFunction("quaternion2point", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternion2point
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternion2point(MWArray q)
    {
      return mcr.EvaluateFunction("quaternion2point", q);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternion2point
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternion2point(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternion2point", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternion2point
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternion2point(int numArgsOut, MWArray q)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternion2point", q);
    }


    /// <summary>
    /// Provides an interface for the quaternion2point function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternion2point(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("quaternion2point", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionConjugate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionConjugate()
    {
      return mcr.EvaluateFunction("quaternionConjugate", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionConjugate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionConjugate(MWArray q)
    {
      return mcr.EvaluateFunction("quaternionConjugate", q);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionConjugate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionConjugate(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionConjugate", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionConjugate
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionConjugate(int numArgsOut, MWArray q)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionConjugate", q);
    }


    /// <summary>
    /// Provides an interface for the quaternionConjugate function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionConjugate(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                          argsIn)
    {
      mcr.EvaluateFunction("quaternionConjugate", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionDistance()
    {
      return mcr.EvaluateFunction("quaternionDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="qDestination">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionDistance(MWArray qDestination)
    {
      return mcr.EvaluateFunction("quaternionDistance", qDestination);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="qDestination">Input argument #1</param>
    /// <param name="qSamples">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionDistance(MWArray qDestination, MWArray qSamples)
    {
      return mcr.EvaluateFunction("quaternionDistance", qDestination, qSamples);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionDistance(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionDistance", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qDestination">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionDistance(int numArgsOut, MWArray qDestination)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionDistance", qDestination);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternionDistance
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qDestination">Input argument #1</param>
    /// <param name="qSamples">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionDistance(int numArgsOut, MWArray qDestination, MWArray 
                                  qSamples)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionDistance", qDestination, qSamples);
    }


    /// <summary>
    /// Provides an interface for the quaternionDistance function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// TODO: Per ara no tenim en compte els pesos.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionDistance(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("quaternionDistance", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// quaternionExponentialMap M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionExponentialMap()
    {
      return mcr.EvaluateFunction("quaternionExponentialMap", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// quaternionExponentialMap M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="p">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionExponentialMap(MWArray p)
    {
      return mcr.EvaluateFunction("quaternionExponentialMap", p);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionExponentialMap
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionExponentialMap(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionExponentialMap", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionExponentialMap
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="p">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionExponentialMap(int numArgsOut, MWArray p)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionExponentialMap", p);
    }


    /// <summary>
    /// Provides an interface for the quaternionExponentialMap function in which the
    /// input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionExponentialMap(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                               argsIn)
    {
      mcr.EvaluateFunction("quaternionExponentialMap", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionInnerProduct()
    {
      return mcr.EvaluateFunction("quaternionInnerProduct", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionInnerProduct(MWArray q1)
    {
      return mcr.EvaluateFunction("quaternionInnerProduct", q1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q1">Input argument #1</param>
    /// <param name="q2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionInnerProduct(MWArray q1, MWArray q2)
    {
      return mcr.EvaluateFunction("quaternionInnerProduct", q1, q2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionInnerProduct(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionInnerProduct", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionInnerProduct(int numArgsOut, MWArray q1)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionInnerProduct", q1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternionInnerProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q1">Input argument #1</param>
    /// <param name="q2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionInnerProduct(int numArgsOut, MWArray q1, MWArray q2)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionInnerProduct", q1, q2);
    }


    /// <summary>
    /// Provides an interface for the quaternionInnerProduct function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionInnerProduct(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                             argsIn)
    {
      mcr.EvaluateFunction("quaternionInnerProduct", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// quaternionLogarithmicMap M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionLogarithmicMap()
    {
      return mcr.EvaluateFunction("quaternionLogarithmicMap", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// quaternionLogarithmicMap M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionLogarithmicMap(MWArray q)
    {
      return mcr.EvaluateFunction("quaternionLogarithmicMap", q);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionLogarithmicMap
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionLogarithmicMap(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionLogarithmicMap", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionLogarithmicMap
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionLogarithmicMap(int numArgsOut, MWArray q)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionLogarithmicMap", q);
    }


    /// <summary>
    /// Provides an interface for the quaternionLogarithmicMap function in which the
    /// input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionLogarithmicMap(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                               argsIn)
    {
      mcr.EvaluateFunction("quaternionLogarithmicMap", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionNorm
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionNorm()
    {
      return mcr.EvaluateFunction("quaternionNorm", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionNorm
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionNorm(MWArray q)
    {
      return mcr.EvaluateFunction("quaternionNorm", q);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionNorm M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionNorm(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionNorm", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionNorm M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionNorm(int numArgsOut, MWArray q)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionNorm", q);
    }


    /// <summary>
    /// Provides an interface for the quaternionNorm function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionNorm(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("quaternionNorm", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionNormalize
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionNormalize()
    {
      return mcr.EvaluateFunction("quaternionNormalize", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionNormalize
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionNormalize(MWArray q1)
    {
      return mcr.EvaluateFunction("quaternionNormalize", q1);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionNormalize
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionNormalize(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionNormalize", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionNormalize
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionNormalize(int numArgsOut, MWArray q1)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionNormalize", q1);
    }


    /// <summary>
    /// Provides an interface for the quaternionNormalize function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionNormalize(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                          argsIn)
    {
      mcr.EvaluateFunction("quaternionNormalize", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionProduct()
    {
      return mcr.EvaluateFunction("quaternionProduct", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionProduct(MWArray q1)
    {
      return mcr.EvaluateFunction("quaternionProduct", q1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="q1">Input argument #1</param>
    /// <param name="q2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionProduct(MWArray q1, MWArray q2)
    {
      return mcr.EvaluateFunction("quaternionProduct", q1, q2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionProduct(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionProduct", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionProduct(int numArgsOut, MWArray q1)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionProduct", q1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternionProduct
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="q1">Input argument #1</param>
    /// <param name="q2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionProduct(int numArgsOut, MWArray q1, MWArray q2)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionProduct", q1, q2);
    }


    /// <summary>
    /// Provides an interface for the quaternionProduct function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// x = q1(2) * q2(1)  + q1(3) * q2(4) - q1(4) * q2(3) + q1(1) * q2(2);
    /// y = -q1(2) * q2(4) + q1(3) * q2(1) + q1(4) * q2(2) + q1(1) * q2(3);
    /// z = q1(2) * q2(3)  - q1(3) * q2(2) + q1(4) * q2(1) + q1(1) * q2(4);
    /// s = -q1(2) * q2(2) - q1(3) * q2(3) - q1(4) * q2(4) + q1(1) * q2(1);
    /// q=[s,x,y,z];</remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionProduct(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("quaternionProduct", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionQuTEMSampling()
    {
      return mcr.EvaluateFunction("quaternionQuTEMSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionQuTEMSampling(MWArray m)
    {
      return mcr.EvaluateFunction("quaternionQuTEMSampling", m);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="pg">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionQuTEMSampling(MWArray m, MWArray pg)
    {
      return mcr.EvaluateFunction("quaternionQuTEMSampling", m, pg);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="pg">Input argument #2</param>
    /// <param name="samples">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionQuTEMSampling(MWArray m, MWArray pg, MWArray samples)
    {
      return mcr.EvaluateFunction("quaternionQuTEMSampling", m, pg, samples);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionQuTEMSampling(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionQuTEMSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionQuTEMSampling(int numArgsOut, MWArray m)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionQuTEMSampling", m);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="pg">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionQuTEMSampling(int numArgsOut, MWArray m, MWArray pg)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionQuTEMSampling", m, pg);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the quaternionQuTEMSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="pg">Input argument #2</param>
    /// <param name="samples">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionQuTEMSampling(int numArgsOut, MWArray m, MWArray pg, 
                                       MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionQuTEMSampling", m, pg, samples);
    }


    /// <summary>
    /// Provides an interface for the quaternionQuTEMSampling function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// s1=s2=s3 =>uniform Sampling
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionQuTEMSampling(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                              argsIn)
    {
      mcr.EvaluateFunction("quaternionQuTEMSampling", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionRotation()
    {
      return mcr.EvaluateFunction("quaternionRotation", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="vector">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionRotation(MWArray vector)
    {
      return mcr.EvaluateFunction("quaternionRotation", vector);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="vector">Input argument #1</param>
    /// <param name="quaternion">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionRotation(MWArray vector, MWArray quaternion)
    {
      return mcr.EvaluateFunction("quaternionRotation", vector, quaternion);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionRotation(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionRotation", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vector">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionRotation(int numArgsOut, MWArray vector)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionRotation", vector);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the quaternionRotation
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="vector">Input argument #1</param>
    /// <param name="quaternion">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionRotation(int numArgsOut, MWArray vector, MWArray 
                                  quaternion)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionRotation", vector, quaternion);
    }


    /// <summary>
    /// Provides an interface for the quaternionRotation function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// Create vector of quaternion point
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionRotation(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("quaternionRotation", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the
    /// quaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionUniformSampling()
    {
      return mcr.EvaluateFunction("quaternionUniformSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the
    /// quaternionUniformSampling M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="samples">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray quaternionUniformSampling(MWArray samples)
    {
      return mcr.EvaluateFunction("quaternionUniformSampling", samples);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the quaternionUniformSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionUniformSampling(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionUniformSampling", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the quaternionUniformSampling
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="samples">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] quaternionUniformSampling(int numArgsOut, MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "quaternionUniformSampling", samples);
    }


    /// <summary>
    /// Provides an interface for the quaternionUniformSampling function in which the
    /// input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void quaternionUniformSampling(int numArgsOut, ref MWArray[] argsOut, 
                                MWArray[] argsIn)
    {
      mcr.EvaluateFunction("quaternionUniformSampling", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the remostrejar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// r
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray remostrejar()
    {
      return mcr.EvaluateFunction("remostrejar", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the remostrejar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// r
    /// </remarks>
    /// <param name="particles">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray remostrejar(MWArray particles)
    {
      return mcr.EvaluateFunction("remostrejar", particles);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the remostrejar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// r
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] remostrejar(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "remostrejar", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the remostrejar M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// r
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="particles">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] remostrejar(int numArgsOut, MWArray particles)
    {
      return mcr.EvaluateFunction(numArgsOut, "remostrejar", particles);
    }


    /// <summary>
    /// Provides an interface for the remostrejar function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// r
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void remostrejar(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("remostrejar", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray rotation2quaternion()
    {
      return mcr.EvaluateFunction("rotation2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="theta">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray rotation2quaternion(MWArray theta)
    {
      return mcr.EvaluateFunction("rotation2quaternion", theta);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray rotation2quaternion(MWArray theta, MWArray x)
    {
      return mcr.EvaluateFunction("rotation2quaternion", theta, x);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <param name="y">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray rotation2quaternion(MWArray theta, MWArray x, MWArray y)
    {
      return mcr.EvaluateFunction("rotation2quaternion", theta, x, y);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <param name="y">Input argument #3</param>
    /// <param name="z">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray rotation2quaternion(MWArray theta, MWArray x, MWArray y, MWArray z)
    {
      return mcr.EvaluateFunction("rotation2quaternion", theta, x, y, z);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] rotation2quaternion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "rotation2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="theta">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] rotation2quaternion(int numArgsOut, MWArray theta)
    {
      return mcr.EvaluateFunction(numArgsOut, "rotation2quaternion", theta);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] rotation2quaternion(int numArgsOut, MWArray theta, MWArray x)
    {
      return mcr.EvaluateFunction(numArgsOut, "rotation2quaternion", theta, x);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <param name="y">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] rotation2quaternion(int numArgsOut, MWArray theta, MWArray x, 
                                   MWArray y)
    {
      return mcr.EvaluateFunction(numArgsOut, "rotation2quaternion", theta, x, y);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the rotation2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="theta">Input argument #1</param>
    /// <param name="x">Input argument #2</param>
    /// <param name="y">Input argument #3</param>
    /// <param name="z">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] rotation2quaternion(int numArgsOut, MWArray theta, MWArray x, 
                                   MWArray y, MWArray z)
    {
      return mcr.EvaluateFunction(numArgsOut, "rotation2quaternion", theta, x, y, z);
    }


    /// <summary>
    /// Provides an interface for the rotation2quaternion function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// theta should divide 2, because the negative quaternion it is the same
    /// rotation of the possitive quaternion.
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void rotation2quaternion(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                          argsIn)
    {
      mcr.EvaluateFunction("rotation2quaternion", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray S_Touch()
    {
      return mcr.EvaluateFunction("S_Touch", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray S_Touch(MWArray chain)
    {
      return mcr.EvaluateFunction("S_Touch", chain);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="S">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray S_Touch(MWArray chain, MWArray S)
    {
      return mcr.EvaluateFunction("S_Touch", chain, S);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] S_Touch(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "S_Touch", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] S_Touch(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "S_Touch", chain);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the S_Touch M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="S">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] S_Touch(int numArgsOut, MWArray chain, MWArray S)
    {
      return mcr.EvaluateFunction(numArgsOut, "S_Touch", chain, S);
    }


    /// <summary>
    /// Provides an interface for the S_Touch function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// S: 
    /// S = [O1 O2 ... Ok]
    /// Ok.ptos: lista de puntos 
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void S_Touch(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("S_Touch", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray setGaussianParameters()
    {
      return mcr.EvaluateFunction("setGaussianParameters", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray setGaussianParameters(MWArray media_gausiana)
    {
      return mcr.EvaluateFunction("setGaussianParameters", media_gausiana);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray setGaussianParameters(MWArray media_gausiana, MWArray rotar_en_x)
    {
      return mcr.EvaluateFunction("setGaussianParameters", media_gausiana, rotar_en_x);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <param name="rotar_en_y">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray setGaussianParameters(MWArray media_gausiana, MWArray rotar_en_x, 
                                   MWArray rotar_en_y)
    {
      return mcr.EvaluateFunction("setGaussianParameters", media_gausiana, rotar_en_x, rotar_en_y);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <param name="rotar_en_y">Input argument #3</param>
    /// <param name="rotar_en_z">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray setGaussianParameters(MWArray media_gausiana, MWArray rotar_en_x, 
                                   MWArray rotar_en_y, MWArray rotar_en_z)
    {
      return mcr.EvaluateFunction("setGaussianParameters", media_gausiana, rotar_en_x, rotar_en_y, rotar_en_z);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setGaussianParameters(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "setGaussianParameters", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setGaussianParameters(int numArgsOut, MWArray media_gausiana)
    {
      return mcr.EvaluateFunction(numArgsOut, "setGaussianParameters", media_gausiana);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setGaussianParameters(int numArgsOut, MWArray media_gausiana, 
                                     MWArray rotar_en_x)
    {
      return mcr.EvaluateFunction(numArgsOut, "setGaussianParameters", media_gausiana, rotar_en_x);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <param name="rotar_en_y">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setGaussianParameters(int numArgsOut, MWArray media_gausiana, 
                                     MWArray rotar_en_x, MWArray rotar_en_y)
    {
      return mcr.EvaluateFunction(numArgsOut, "setGaussianParameters", media_gausiana, rotar_en_x, rotar_en_y);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the setGaussianParameters
    /// M-function.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="media_gausiana">Input argument #1</param>
    /// <param name="rotar_en_x">Input argument #2</param>
    /// <param name="rotar_en_y">Input argument #3</param>
    /// <param name="rotar_en_z">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] setGaussianParameters(int numArgsOut, MWArray media_gausiana, 
                                     MWArray rotar_en_x, MWArray rotar_en_y, MWArray 
                                     rotar_en_z)
    {
      return mcr.EvaluateFunction(numArgsOut, "setGaussianParameters", media_gausiana, rotar_en_x, rotar_en_y, rotar_en_z);
    }


    /// <summary>
    /// Provides an interface for the setGaussianParameters function in which the input
    /// and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void setGaussianParameters(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                            argsIn)
    {
      mcr.EvaluateFunction("setGaussianParameters", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray slerp()
    {
      return mcr.EvaluateFunction("slerp", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="qOrigin">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray slerp(MWArray qOrigin)
    {
      return mcr.EvaluateFunction("slerp", qOrigin);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray slerp(MWArray qOrigin, MWArray qDestination)
    {
      return mcr.EvaluateFunction("slerp", qOrigin, qDestination);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray slerp(MWArray qOrigin, MWArray qDestination, MWArray f)
    {
      return mcr.EvaluateFunction("slerp", qOrigin, qDestination, f);
    }


    /// <summary>
    /// Provides a single output, 4-input MWArrayinterface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <param name="epsilon">Input argument #4</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray slerp(MWArray qOrigin, MWArray qDestination, MWArray f, MWArray 
                   epsilon)
    {
      return mcr.EvaluateFunction("slerp", qOrigin, qDestination, f, epsilon);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] slerp(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "slerp", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qOrigin">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] slerp(int numArgsOut, MWArray qOrigin)
    {
      return mcr.EvaluateFunction(numArgsOut, "slerp", qOrigin);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] slerp(int numArgsOut, MWArray qOrigin, MWArray qDestination)
    {
      return mcr.EvaluateFunction(numArgsOut, "slerp", qOrigin, qDestination);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] slerp(int numArgsOut, MWArray qOrigin, MWArray qDestination, MWArray 
                     f)
    {
      return mcr.EvaluateFunction(numArgsOut, "slerp", qOrigin, qDestination, f);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the slerp M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="qOrigin">Input argument #1</param>
    /// <param name="qDestination">Input argument #2</param>
    /// <param name="f">Input argument #3</param>
    /// <param name="epsilon">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] slerp(int numArgsOut, MWArray qOrigin, MWArray qDestination, MWArray 
                     f, MWArray epsilon)
    {
      return mcr.EvaluateFunction(numArgsOut, "slerp", qOrigin, qDestination, f, epsilon);
    }


    /// <summary>
    /// Provides an interface for the slerp function in which the input and output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// the quaternions are pointing in opposite direction, so use the
    /// equivalent alternative representation
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void slerp(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("slerp", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a void output, 0-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    ///
    public void testQuTEM()
    {
      mcr.EvaluateFunction(0, "testQuTEM", new MWArray[]{});
    }


    /// <summary>
    /// Provides a void output, 1-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    ///
    public void testQuTEM(MWArray m)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m);
    }


    /// <summary>
    /// Provides a void output, 2-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    ///
    public void testQuTEM(MWArray m, MWArray s)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m, s);
    }


    /// <summary>
    /// Provides a void output, 3-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    ///
    public void testQuTEM(MWArray m, MWArray s, MWArray s1)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m, s, s1);
    }


    /// <summary>
    /// Provides a void output, 4-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    ///
    public void testQuTEM(MWArray m, MWArray s, MWArray s1, MWArray s2)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m, s, s1, s2);
    }


    /// <summary>
    /// Provides a void output, 5-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    /// <param name="s3">Input argument #5</param>
    ///
    public void testQuTEM(MWArray m, MWArray s, MWArray s1, MWArray s2, MWArray s3)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m, s, s1, s2, s3);
    }


    /// <summary>
    /// Provides a void output, 6-input MWArrayinterface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    /// <param name="s3">Input argument #5</param>
    /// <param name="samples">Input argument #6</param>
    ///
    public void testQuTEM(MWArray m, MWArray s, MWArray s1, MWArray s2, MWArray s3, 
                    MWArray samples)
    {
      mcr.EvaluateFunction(0, "testQuTEM", m, s, s1, s2, s3, samples);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m, MWArray s)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m, s);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m, MWArray s, MWArray s1)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m, s, s1);
    }


    /// <summary>
    /// Provides the standard 4-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m, MWArray s, MWArray s1, MWArray 
                         s2)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m, s, s1, s2);
    }


    /// <summary>
    /// Provides the standard 5-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    /// <param name="s3">Input argument #5</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m, MWArray s, MWArray s1, MWArray 
                         s2, MWArray s3)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m, s, s1, s2, s3);
    }


    /// <summary>
    /// Provides the standard 6-input MWArray interface to the testQuTEM M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// p=quaternionUniformSampling(samples);
    /// for i = 1:samples
    /// p(i,:)=quaternionNormalize(p(i,:));
    /// end
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="m">Input argument #1</param>
    /// <param name="s">Input argument #2</param>
    /// <param name="s1">Input argument #3</param>
    /// <param name="s2">Input argument #4</param>
    /// <param name="s3">Input argument #5</param>
    /// <param name="samples">Input argument #6</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] testQuTEM(int numArgsOut, MWArray m, MWArray s, MWArray s1, MWArray 
                         s2, MWArray s3, MWArray samples)
    {
      return mcr.EvaluateFunction(numArgsOut, "testQuTEM", m, s, s1, s2, s3, samples);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray vectors2quaternion()
    {
      return mcr.EvaluateFunction("vectors2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="v1">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray vectors2quaternion(MWArray v1)
    {
      return mcr.EvaluateFunction("vectors2quaternion", v1);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="v1">Input argument #1</param>
    /// <param name="v2">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray vectors2quaternion(MWArray v1, MWArray v2)
    {
      return mcr.EvaluateFunction("vectors2quaternion", v1, v2);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] vectors2quaternion(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "vectors2quaternion", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="v1">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] vectors2quaternion(int numArgsOut, MWArray v1)
    {
      return mcr.EvaluateFunction(numArgsOut, "vectors2quaternion", v1);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the vectors2quaternion
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="v1">Input argument #1</param>
    /// <param name="v2">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] vectors2quaternion(int numArgsOut, MWArray v1, MWArray v2)
    {
      return mcr.EvaluateFunction(numArgsOut, "vectors2quaternion", v1, v2);
    }


    /// <summary>
    /// Provides an interface for the vectors2quaternion function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// s = sin(angle/2);
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void vectors2quaternion(int numArgsOut, ref MWArray[] argsOut, MWArray[] 
                         argsIn)
    {
      mcr.EvaluateFunction("vectors2quaternion", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// Provides a single output, 0-input MWArrayinterface to the weightFunction
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray weightFunction()
    {
      return mcr.EvaluateFunction("weightFunction", new MWArray[]{});
    }


    /// <summary>
    /// Provides a single output, 1-input MWArrayinterface to the weightFunction
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray weightFunction(MWArray chain)
    {
      return mcr.EvaluateFunction("weightFunction", chain);
    }


    /// <summary>
    /// Provides a single output, 2-input MWArrayinterface to the weightFunction
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray weightFunction(MWArray chain, MWArray goal)
    {
      return mcr.EvaluateFunction("weightFunction", chain, goal);
    }


    /// <summary>
    /// Provides a single output, 3-input MWArrayinterface to the weightFunction
    /// M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An MWArray containing the first output argument.</returns>
    ///
    public MWArray weightFunction(MWArray chain, MWArray goal, MWArray S)
    {
      return mcr.EvaluateFunction("weightFunction", chain, goal, S);
    }


    /// <summary>
    /// Provides the standard 0-input MWArray interface to the weightFunction M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] weightFunction(int numArgsOut)
    {
      return mcr.EvaluateFunction(numArgsOut, "weightFunction", new MWArray[]{});
    }


    /// <summary>
    /// Provides the standard 1-input MWArray interface to the weightFunction M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] weightFunction(int numArgsOut, MWArray chain)
    {
      return mcr.EvaluateFunction(numArgsOut, "weightFunction", chain);
    }


    /// <summary>
    /// Provides the standard 2-input MWArray interface to the weightFunction M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] weightFunction(int numArgsOut, MWArray chain, MWArray goal)
    {
      return mcr.EvaluateFunction(numArgsOut, "weightFunction", chain, goal);
    }


    /// <summary>
    /// Provides the standard 3-input MWArray interface to the weightFunction M-function.
    /// </summary>
    /// <remarks>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return.</param>
    /// <param name="chain">Input argument #1</param>
    /// <param name="goal">Input argument #2</param>
    /// <param name="S">Input argument #3</param>
    /// <returns>An Array of length "numArgsOut" containing the output
    /// arguments.</returns>
    ///
    public MWArray[] weightFunction(int numArgsOut, MWArray chain, MWArray goal, MWArray 
                              S)
    {
      return mcr.EvaluateFunction(numArgsOut, "weightFunction", chain, goal, S);
    }


    /// <summary>
    /// Provides an interface for the weightFunction function in which the input and
    /// output
    /// arguments are specified as an array of MWArrays.
    /// </summary>
    /// <remarks>
    /// This method will allocate and return by reference the output argument
    /// array.<newpara></newpara>
    /// M-Documentation:
    /// euclideanDistance
    /// </remarks>
    /// <param name="numArgsOut">The number of output arguments to return</param>
    /// <param name= "argsOut">Array of MWArray output arguments</param>
    /// <param name= "argsIn">Array of MWArray input arguments</param>
    ///
    public void weightFunction(int numArgsOut, ref MWArray[] argsOut, MWArray[] argsIn)
    {
      mcr.EvaluateFunction("weightFunction", numArgsOut, ref argsOut, argsIn);
    }


    /// <summary>
    /// This method will cause a MATLAB figure window to behave as a modal dialog box.
    /// The method will not return until all the figure windows associated with this
    /// component have been closed.
    /// </summary>
    /// <remarks>
    /// An application should only call this method when required to keep the
    /// MATLAB figure window from disappearing.  Other techniques, such as calling
    /// Console.ReadLine() from the application should be considered where
    /// possible.</remarks>
    ///
    public void WaitForFiguresToDie()
    {
      mcr.WaitForFiguresToDie();
    }



    #endregion Methods

    #region Class Members

    private static MWMCR mcr= null;

    private bool disposed= false;

    #endregion Class Members
  }
}
